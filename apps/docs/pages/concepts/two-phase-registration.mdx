import { Mermaid } from '../../components/Mermaid';

# Two-Phase Registration

SWR uses a two-phase registration model to prevent phishing attacks. An attacker who tricks a victim into signing one transaction cannot complete registration without a second, separate signature minutes later.

## Why Two Phases?

Single-transaction registration is vulnerable to social engineering. If an attacker creates a fake "security check" site that prompts a wallet signature, a single-signature model would immediately register the wallet as stolen.

Two-phase registration breaks this attack:

1. The victim would need to sign **twice**, minutes apart
2. The randomized grace period makes automation unreliable
3. The acknowledgement deadline expires (~10-20 minutes after acknowledgement, depending on randomization) — the attacker must trick the victim into signing a second transaction within this narrow window or the acknowledgement becomes invalid
4. A second, unsolicited signature request minutes after the first **should** raise suspicion for any attentive user — though this is a behavioral assumption, not a technical guarantee

:::warning
Two-phase registration is an added layer of social engineering protection, not a guarantee. A sufficiently motivated attacker with sustained access to a victim could still complete both phases within the registration window. The design raises the bar significantly — it does not eliminate all risk.
:::

## The Three Phases

<Mermaid chart={`
sequenceDiagram
    participant U as User (Wallet)
    participant C as Contract
    participant B as Blockchain

    U->>C: Sign ACK (EIP-712)
    C->>B: Submit acknowledge()
    Note over B: Grace period begins<br/>(1-4 min randomized delay)
    rect rgb(255, 245, 230)
    Note over B: Registration window open<br/>(~8-10 min before expiry)
    U->>C: Sign REG (EIP-712)
    C->>B: Submit register()
    B-->>C: Wallet permanently registered
    end
    Note over B: If window expires:<br/>acknowledgement is invalid,<br/>must restart from Phase 1

`} />

### Phase 1: Acknowledgement

The user signs an EIP-712 typed message declaring their wallet stolen. The contract:

- Verifies the signature came from the wallet owner
- Validates the nonce and deadline
- Stores a pending acknowledgement with randomized timing
- Emits `WalletAcknowledged` event

### Phase 2: Grace Period & Registration Window

A randomized delay using `block.prevrandao` prevents timing attacks. The user cannot proceed until the grace period ends, and must complete registration before the acknowledgement expires.

The registration window is the time between the end of the grace period and the acknowledgement deadline. If the user does not complete the second signature within this window, the acknowledgement becomes invalid and the entire process must restart from Phase 1. This expiry is central to the social engineering protection — an attacker has a narrow, non-renewable window to coerce a second signature.

Both the grace period and deadline include randomized jitter (up to 1x the base block count via `block.prevrandao`), so actual timing varies per registration.

| Chain           | Block Time | Grace Blocks | Deadline Blocks | Grace Period | Ack Deadline (from ack) |
| --------------- | ---------- | ------------ | --------------- | ------------ | ----------------------- |
| Anvil (local)   | 13s        | 2            | 50              | ~30s - 1 min | ~10 - 20 min            |
| Base / Optimism | 2s         | 60           | 300             | ~2 - 4 min   | ~10 - 20 min            |
| Arbitrum        | 0.25s      | 480          | 2400            | ~2 - 4 min   | ~10 - 20 min            |
| Ethereum L1     | 12s        | 10           | 50              | ~2 - 4 min   | ~10 - 20 min            |

Block counts are derived from `TimingConfig.sol` and configured per chain in `DeployBase.s.sol` to maintain consistent UX across chains. The formula is: `block.number + random(0, baseBlocks) + baseBlocks`.

### Phase 3: Registration

The user signs a second EIP-712 message confirming permanent registration. The contract:

- Validates the stored acknowledgement (trustedForwarder, timing, chain data)
- Verifies the second signature
- Stores the wallet entry permanently
- Deletes acknowledgement data
- Collects registration fee

## EIP-712 Typehashes

All contracts share domain name `"StolenWalletRegistry"` version `"4"`. Cross-contract replay is prevented by **distinct typehashes**, not domain separation.

### Wallet Registration

```solidity
// Acknowledgement
AcknowledgementOfRegistry(
    string statement,
    address wallet,
    address trustedForwarder,
    uint64 reportedChainId,
    uint64 incidentTimestamp,
    uint256 nonce,
    uint256 deadline
)

// Registration
Registration(
    string statement,
    address wallet,
    address trustedForwarder,
    uint64 reportedChainId,
    uint64 incidentTimestamp,
    uint256 nonce,
    uint256 deadline
)
```

### Transaction Batch Registration

```solidity
// Acknowledgement
TransactionBatchAcknowledgement(
    string statement,
    address reporter,
    address trustedForwarder,
    bytes32 dataHash,
    bytes32 reportedChainId,
    uint32 transactionCount,
    uint256 nonce,
    uint256 deadline
)

// Registration
TransactionBatchRegistration(
    string statement,
    address reporter,
    address trustedForwarder,
    bytes32 dataHash,
    bytes32 reportedChainId,
    uint32 transactionCount,
    uint256 nonce,
    uint256 deadline
)
```

The `statement` field contains a human-readable message displayed in MetaMask during signing (e.g., _"This signature acknowledges that the signing wallet is being reported as stolen..."_). It is hashed at compile time for gas efficiency.

## Nonce & Deadline Mechanics

**Nonce** - Sequential counter per address. Prevents replay attacks. Each successful acknowledgement or registration increments the nonce. The contract rejects any submission where the nonce doesn't match the expected value.

**Deadline** - Two distinct deadline concepts are in play:

| Deadline              | Unit              | Purpose                                                                            |
| --------------------- | ----------------- | ---------------------------------------------------------------------------------- |
| Signature deadline    | `block.timestamp` | EIP-712 signature expiry. Prevents stale signatures from being submitted.          |
| Grace period deadline | `block.number`    | Registration window. Defines when the user can start and must finish registration. |

Both include randomized jitter via `block.prevrandao` to prevent prediction.

## Registration Methods & the Forwarder Field

The `trustedForwarder` parameter in the signature determines who can submit the registration transaction and pay gas.

| Method         | `wallet`   | `trustedForwarder` | Who pays gas                     |
| -------------- | ---------- | ------------------ | -------------------------------- |
| **Standard**   | `0xVictim` | `0xVictim`         | Same wallet                      |
| **Self-relay** | `0xVictim` | `0xFunder`         | Different wallet owned by victim |
| **P2P relay**  | `0xVictim` | `0xHelper`         | Third-party helper via libp2p    |

In all cases:

- The **wallet owner** must sign both EIP-712 messages
- The `trustedForwarder` is named in the signature (cannot be changed after signing)
- Only the `trustedForwarder` can submit the `register()` transaction
- `isSponsored` is derived from `wallet != trustedForwarder`

For self-relay and P2P relay, the victim signs with their compromised wallet but someone else submits the transaction and pays gas - critical when the wallet has been drained.

:::info
The `trustedForwarder` address **is** emitted as an indexed event parameter in `WalletAcknowledged` and `TransactionBatchAcknowledged` events, so it is publicly queryable on-chain. The `isSponsored` boolean signals whether someone other than the wallet owner paid gas, but the forwarder identity is not hidden.
:::
