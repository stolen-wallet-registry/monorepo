# EIP-712 Signatures

The security-critical two-phase signature system.

## Why Two Phases?

Single-signature phishing is trivial:

```
Attacker tricks victim → victim signs → wallet registered as stolen
```

With two phases:

1. Victim signs ACK → grace period starts (1-4 min)
2. Attacker needs SECOND signature → victim notices two wallet prompts

**This is the core security mechanism of the registry.**

## EIP-712 Overview

EIP-712 is a standard for typed structured data hashing and signing. It provides:

- **Human-readable messages** - Users see what they're signing
- **Domain separation** - Signatures are bound to specific contracts
- **Type safety** - Structured data prevents ambiguity

## Domain Separator

The domain uniquely identifies the contract and chain:

```typescript
const domain = {
  name: 'StolenWalletRegistry',
  version: '4',
  chainId: 8453, // Base
  verifyingContract: '0x...',
};
```

**Why this matters:**

- `chainId` prevents replay across networks
- `verifyingContract` binds to specific deployment
- `version` allows for upgrades

## Type Definitions

```typescript
const EIP712_TYPES = {
  AcknowledgementOfRegistry: [
    { name: 'owner', type: 'address' },
    { name: 'forwarder', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' },
  ],
  Registration: [
    { name: 'owner', type: 'address' },
    { name: 'forwarder', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' },
  ],
};
```

**Note:** ACK and REG have identical structure but different `primaryType`, generating distinct hashes.

## Message Parameters

| Parameter   | Description                                              |
| ----------- | -------------------------------------------------------- |
| `owner`     | Wallet being registered as stolen                        |
| `forwarder` | Who submits the transaction (same as owner for standard) |
| `nonce`     | Prevents replay (increments after each phase)            |
| `deadline`  | Block number when signature expires                      |

## Signature Flow

### Phase 1: Acknowledgement

```
┌─────────────────────────────────────┐
│ 1. Query contract for deadline      │
│    generateHashStruct(address, 1)   │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Build typed data                 │
│    domain + types + message         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Sign with wallet                 │
│    signTypedData(typedData)         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. Submit to contract               │
│    acknowledgementOfRegistry(...)   │
└─────────────────────────────────────┘
```

### Grace Period

After acknowledgement:

- Contract records `startBlock` and `expiryBlock`
- Uses `block.prevrandao` for randomization
- Start: ~1-2 minutes from ACK (4-8 blocks)
- Window: ~4-13 minutes total (55-110 blocks)

### Phase 2: Registration

Same flow as ACK but with:

- `primaryType: 'Registration'`
- Nonce incremented by 1
- New deadline from `generateHashStruct(address, 2)`

## Contract Verification

```solidity
// Acknowledgement verification
bytes32 digest = _hashTypedDataV4(structHash);
address recoveredWallet = ECDSA.recover(digest, v, r, s);

if (recoveredWallet != owner) revert InvalidSigner();

nonces[owner]++;  // Replay prevention

// Store trusted forwarder
trustedForwarders[owner] = TrustedForwarder({
    forwarder: forwarder,
    startBlock: calculateStart(),
    expiryBlock: calculateExpiry()
});
```

```solidity
// Registration verification
TrustedForwarder memory tf = trustedForwarders[owner];

if (tf.forwarder != msg.sender) revert InvalidForwarder();
if (block.number < tf.startBlock) revert GracePeriodNotStarted();
if (block.number > tf.expiryBlock) revert WindowExpired();

// Verify signature and register
```

## Nonce Mechanics

```
Initial: nonces[0x123] = 0

ACK tx:
  - Contract verifies nonce=0 ✓
  - Increments to 1
  - Signature with nonce=0 now INVALID forever

REG tx:
  - Contract verifies nonce=1 ✓
  - Increments to 2
  - Signature with nonce=1 now INVALID forever
```

This prevents replay attacks - each signature can only be used once.

## Signature Storage

The frontend stores signatures in sessionStorage:

```typescript
interface StoredSignature {
  signature: `0x${string}`;
  deadline: bigint;
  nonce: bigint;
  address: `0x${string}`;
  chainId: number;
  step: SignatureStep; // ACK (1) or REG (2)
  storedAt: number; // For 30-min TTL
}

// Key format
const key = `swr_sig_${address}_${chainId}_${step}`;
```

**TTL:** Signatures expire client-side after 30 minutes.

## Flow by Registration Method

### Standard

User signs both, pays both:

```
Sign ACK → Pay ACK → Grace Period → Sign REG → Pay REG
```

### Self-Relay

Sign with stolen wallet, pay with gas wallet:

```
Sign ACK (stolen) → Switch → Pay ACK (gas)
       ↓
   Grace Period
       ↓
Sign REG (stolen) → Switch → Pay REG (gas)
```

### P2P Relay

Sign with stolen wallet, helper pays:

```
Sign ACK → Send via P2P → Helper pays
       ↓
   Grace Period
       ↓
Sign REG → Send via P2P → Helper pays
```

## Code Examples

### Generating Typed Data

```typescript
import { type TypedDataDomain } from 'viem';

function buildAcknowledgementTypedData(
  chainId: number,
  contractAddress: `0x${string}`,
  message: {
    owner: `0x${string}`;
    forwarder: `0x${string}`;
    nonce: bigint;
    deadline: bigint;
  }
) {
  const domain: TypedDataDomain = {
    name: 'StolenWalletRegistry',
    version: '4',
    chainId,
    verifyingContract: contractAddress,
  };

  return {
    domain,
    types: EIP712_TYPES,
    primaryType: 'AcknowledgementOfRegistry' as const,
    message,
  };
}
```

### Signing with wagmi

```typescript
import { useSignTypedData } from 'wagmi';

const { signTypedDataAsync } = useSignTypedData();

const signature = await signTypedDataAsync({
  domain,
  types: EIP712_TYPES,
  primaryType: 'AcknowledgementOfRegistry',
  message: {
    owner: registereeAddress,
    forwarder: relayerAddress,
    nonce: currentNonce,
    deadline: deadlineFromContract,
  },
});
```

### Extracting v, r, s

```typescript
function splitSignature(signature: `0x${string}`) {
  const r = `0x${signature.slice(2, 66)}` as `0x${string}`;
  const s = `0x${signature.slice(66, 130)}` as `0x${string}`;
  const v = parseInt(signature.slice(130, 132), 16);
  return { v, r, s };
}
```

## Security Properties

| Property          | Mechanism                           |
| ----------------- | ----------------------------------- |
| Chain-binding     | Domain includes `chainId`           |
| Contract-binding  | Domain includes `verifyingContract` |
| Phase separation  | Different `primaryType`             |
| Replay prevention | Nonce increments                    |
| Time expiration   | `deadline` checked on-chain         |
| Grace period      | 1-4 min randomized delay            |
| Client TTL        | 30-min sessionStorage expiration    |

## Common Issues

### Invalid Signer

The recovered address doesn't match `owner`. Check:

- Correct domain parameters
- Correct message values
- Signed with the right wallet

### Nonce Already Used

You're using an old nonce. Get the current nonce:

```typescript
const nonce = await publicClient.readContract({
  address: contractAddress,
  abi,
  functionName: 'nonces',
  args: [walletAddress],
});
```

### Deadline Expired

The deadline block has passed. Get a fresh deadline:

```typescript
const [deadline] = await publicClient.readContract({
  address: contractAddress,
  abi,
  functionName: 'generateHashStruct',
  args: [walletAddress, signatureStep],
});
```

## Key Files

```
apps/web/src/lib/signatures/
├── eip712.ts    # Type definitions, builders
├── storage.ts   # sessionStorage persistence
└── utils.ts     # Parsing, validation
```
