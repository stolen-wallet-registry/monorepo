# EIP-712 Signatures

The security-critical two-phase signature system.

## Why Two Phases?

Single-signature phishing is trivial:

```
Attacker tricks victim → victim signs → wallet registered as stolen
```

With two phases:

1. Victim signs ACK → grace period starts (1-4 min)
2. Attacker needs SECOND signature → victim notices two wallet prompts

**This is the core security mechanism of the registry.**

## EIP-712 Overview

EIP-712 is a standard for typed structured data hashing and signing. It provides:

- **Human-readable messages** - Users see what they're signing
- **Domain separation** - Signatures are bound to specific contracts
- **Type safety** - Structured data prevents ambiguity

## Domain Separator

The domain uniquely identifies the contract and chain:

```typescript
const domain = {
  name: 'StolenWalletRegistry',
  version: '4',
  chainId: chainId, // Use your current chain (see table below)
  verifyingContract: '0x...', // Contract address for your chain
};
```

| Network          | chainId  |
| ---------------- | -------- |
| Base             | 8453     |
| Base Sepolia     | 84532    |
| Optimism         | 10       |
| Optimism Sepolia | 11155420 |

**Why this matters:**

- `chainId` prevents replay across networks
- `verifyingContract` binds to specific deployment
- `version` allows for upgrades

## Type Definitions

```typescript
const EIP712_TYPES = {
  AcknowledgementOfRegistry: [
    { name: 'owner', type: 'address' },
    { name: 'forwarder', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' },
  ],
  Registration: [
    { name: 'owner', type: 'address' },
    { name: 'forwarder', type: 'address' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' },
  ],
};
```

**Note:** ACK and REG have identical structure but different `primaryType`, generating distinct hashes.

## Message Parameters

| Parameter   | Description                                              |
| ----------- | -------------------------------------------------------- |
| `owner`     | Wallet being registered as stolen                        |
| `forwarder` | Who submits the transaction (same as owner for standard) |
| `nonce`     | Prevents replay (increments after each phase)            |
| `deadline`  | Block number when signature expires                      |

## Signature Flow

### Phase 1: Acknowledgement

```
┌───────────────────────────────────────────────┐
│ 1. Query contract for deadline                │
│    generateHashStruct(forwarder, 1)           │
│    Returns: (deadline, hashStruct)            │
└──────────────┬────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Build typed data                 │
│    domain + types + message         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Sign with wallet                 │
│    signTypedData(typedData)         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. Submit to contract               │
│    acknowledge(...)                 │
└─────────────────────────────────────┘
```

### Grace Period

After acknowledgement:

- Contract records `graceEndBlock` and `deadlineBlock`
- Uses `block.prevrandao` for randomization
- Grace period ends: ~1-2 minutes from ACK (configurable blocks)
- Window closes: ~4-13 minutes total (configurable blocks)

> **Note:** These timing values are approximate and vary by chain. Block times differ across L2s (Base ~2s, Ethereum ~12s). The contract uses configurable `graceBlocks` and `deadlineBlocks` parameters set at deployment. See `TimingConfig.sol` for chain-specific values.

### Phase 2: Registration

Same flow as ACK but with:

- `primaryType: 'Registration'`
- Nonce incremented by 1 (query `nonces(owner)` again)
- New deadline from `generateHashStruct(forwarder, 2)` (returns `deadline` and `hashStruct`)

## Contract Verification

```solidity
// Acknowledgement verification
bytes32 digest = _hashTypedDataV4(structHash);
address recoveredWallet = ECDSA.recover(digest, v, r, s);

if (recoveredWallet != owner) revert Acknowledgement__InvalidSigner();

nonces[owner]++;  // Replay prevention

// Store acknowledgement data
acknowledgements[owner] = AcknowledgementData({
    forwarder: forwarder,
    graceEndBlock: getGracePeriodEndBlock(graceBlocks),
    deadlineBlock: getDeadlineBlock(deadlineBlocks)
});
```

```solidity
// Registration verification
AcknowledgementData memory ack = acknowledgements[owner];

if (ack.forwarder != msg.sender) revert Registration__InvalidForwarder();
if (block.number < ack.graceEndBlock) revert Registration__GracePeriodNotStarted();
if (block.number > ack.deadlineBlock) revert Registration__ForwarderExpired();

// Verify signature and register
```

## Nonce Mechanics

```
Initial: nonces[0x123] = 0

ACK tx:
  - Contract verifies nonce=0 ✓
  - Increments to 1
  - Signature with nonce=0 now INVALID forever

REG tx:
  - Contract verifies nonce=1 ✓
  - Increments to 2
  - Signature with nonce=1 now INVALID forever
```

This prevents replay attacks - each signature can only be used once.

## Signature Storage

The frontend stores signatures in sessionStorage:

```typescript
interface StoredSignature {
  signature: `0x${string}`;
  deadline: bigint;
  nonce: bigint;
  address: `0x${string}`;
  chainId: number;
  step: SignatureStep; // ACK (1) or REG (2)
  storedAt: number; // For 30-min TTL
}

// Key format
const key = `swr_sig_${address}_${chainId}_${step}`;
```

**TTL:** Signatures expire client-side after 30 minutes.

## Flow by Registration Method

### Standard

User signs both, pays both:

```
Sign ACK → Pay ACK → Grace Period → Sign REG → Pay REG
```

### Self-Relay

Sign with stolen wallet, pay with gas wallet:

```
Sign ACK (stolen) → Switch → Pay ACK (gas)
       ↓
   Grace Period
       ↓
Sign REG (stolen) → Switch → Pay REG (gas)
```

### P2P Relay

Sign with stolen wallet, helper pays:

```
Sign ACK → Send via P2P → Helper pays
       ↓
   Grace Period
       ↓
Sign REG → Send via P2P → Helper pays
```

## Code Examples

### Generating Typed Data

```typescript
import { type TypedDataDomain } from 'viem';

function buildAcknowledgementTypedData(
  chainId: number,
  contractAddress: `0x${string}`,
  message: {
    owner: `0x${string}`;
    forwarder: `0x${string}`;
    nonce: bigint;
    deadline: bigint;
  }
) {
  const domain: TypedDataDomain = {
    name: 'StolenWalletRegistry',
    version: '4',
    chainId,
    verifyingContract: contractAddress,
  };

  return {
    domain,
    types: EIP712_TYPES,
    primaryType: 'AcknowledgementOfRegistry' as const,
    message,
  };
}
```

### Signing with wagmi

```typescript
import { useSignTypedData } from 'wagmi';

const { signTypedDataAsync } = useSignTypedData();

const signature = await signTypedDataAsync({
  domain,
  types: EIP712_TYPES,
  primaryType: 'AcknowledgementOfRegistry',
  message: {
    owner: registereeAddress,
    forwarder: relayerAddress,
    nonce: currentNonce,
    deadline: deadlineFromContract,
  },
});
```

### Extracting v, r, s

Using viem's built-in utility (recommended):

```typescript
import { hexToSignature } from 'viem';

const { v, r, s } = hexToSignature(signature);
// v is already normalized to 27/28
```

Manual extraction (if needed):

```typescript
function splitSignature(signature: `0x${string}`) {
  const r = `0x${signature.slice(2, 66)}` as `0x${string}`;
  const s = `0x${signature.slice(66, 130)}` as `0x${string}`;
  let v = parseInt(signature.slice(130, 132), 16);
  // Normalize v: some wallets return 0/1, contract expects 27/28
  if (v < 27) v += 27;
  return { v, r, s };
}
```

## Security Properties

| Property          | Mechanism                           |
| ----------------- | ----------------------------------- |
| Chain-binding     | Domain includes `chainId`           |
| Contract-binding  | Domain includes `verifyingContract` |
| Phase separation  | Different `primaryType`             |
| Replay prevention | Nonce increments                    |
| Time expiration   | `deadline` checked on-chain         |
| Grace period      | 1-4 min randomized delay            |
| Client TTL        | 30-min sessionStorage expiration    |

## Common Issues

### Invalid Signer

The recovered address doesn't match `owner`. Check:

- Correct domain parameters
- Correct message values
- Signed with the right wallet

### Nonce Already Used

You're using an old nonce. Get the current nonce:

```typescript
const nonce = await publicClient.readContract({
  address: contractAddress,
  abi,
  functionName: 'nonces',
  args: [walletAddress],
});
```

### Deadline Expired

The deadline has passed. Get a fresh deadline:

```typescript
const [deadline, hashStruct] = await publicClient.readContract({
  address: contractAddress,
  abi,
  functionName: 'generateHashStruct',
  args: [forwarderAddress, step], // step: 1 for ACK, 2 for REG
});
```

## Key Files

```
apps/web/src/lib/signatures/
├── eip712.ts    # Type definitions, builders
├── storage.ts   # sessionStorage persistence
└── utils.ts     # Parsing, validation
```
